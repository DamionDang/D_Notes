# 分页查询请不要再使用OFFSET 和 LIMIT

![](https://github.com/DamionDang/D_Notes/blob/678254d8ca96c79b0b0217e227be0b03dba5eaf7/sql/sql%E4%BC%98%E5%8C%96/image1.png)

我们需要担心数据库性能优化的日子已经是常态了。

如果你是一名后端或者数据库架构，或者说你用到了数据库。那么你的分页一定是像这样的

`SELECT * FROM table_name LIMIT 10 OFFSET 40;`

对么？

好吧，如果你确实这样做分页的话，那么很抱歉的说这样是会有性能问题的。

那我们广泛使用的实现存在哪些问题以及如何实现高性能分页。

## OFFSET 和 LIMIT 有什么问题？

正如我们在前几段中简要探讨的那样，OFFSET 和 LIMIT 非常适用于数据使用量低或不使用的项目。

当您的数据库开始收集的数据多于您的服务器可以存储在内存中的数据并且您仍然需要对它们进行高效分页时，就会出现问题。

为此，每次请求分页时，数据库都需要执行低效的*全表扫描*（插入和删除可能同时发生，我们不想要过时的数据！）。

**什么是全表扫描？***全表扫描（又名顺序扫描）是在数据库中进行的扫描，其中顺序读取表中的每一行，然后检查遇到的列的条件有效性。已知这种类型的扫描是最慢的，因为从磁盘读取的大量 I/O 包含多个寻道以及昂贵的磁盘到内存传输。*

这意味着，如果您有 100.000.000 个用户并且您请求 50.000.000 的 OFFSET，它将需要获取所有这些记录（甚至不需要！），将它们放入内存中，然后才获得LIMIT 中指定的 20 个结果。

**TLDR；**OFFSET 越高，查询所需的时间就越长。

## 你应该使用什么

这是你应该使用的：

`SELECT * FROM table_name WHERE id>10 LIMIT 20;`

这是一个**基于id的分页**。

您应该存储最后接收到的主键（通常是一个 ID）和 LIMIT，而不是在本地存储当前的 OFFSET 和 LIMIT 并在每个请求中传递它，这样查询最终可能与这个类似。

为什么？因为通过显式传递最新读取的行，您可以根据有效的索引键准确地告诉数据库从哪里开始搜索，而不必考虑该范围之外的任何行。

以下面的比较为例：

![](https://github.com/DamionDang/D_Notes/blob/678254d8ca96c79b0b0217e227be0b03dba5eaf7/sql/sql%E4%BC%98%E5%8C%96/images2.png)

针对我们的优化版本：

![](https://github.com/DamionDang/D_Notes/blob/678254d8ca96c79b0b0217e227be0b03dba5eaf7/sql/sql%E4%BC%98%E5%8C%96/images3.png)

收到了完全相同的记录，但第一个查询用了*12.80*秒，第二个用了 0.01 秒。你能意识到其中的区别吗？

## 注意事项

为了让光标分页无缝工作，您需要有一个唯一的、连续的列（或多列），例如唯一的整数 ID 或时间戳字段，这在某些特定情况下可能会破坏交易。

与往常一样，我的建议是始终考虑每种表架构的优缺点以及您需要在每种表架构中执行哪种查询。

如果我们手头的问题与没有主键有关，比如我们有一个多对多的关系表，传统的 OFFSET/LIMIT 方法总是适用于这些情况，但是这会重新引入潜在的慢查询. 所以我建议在你想要分页的表中使用自动递增的主键，即使它只是为了分页。

## 结论

这样做的主要内容应该是始终检查您的查询是如何执行的，无论是 1k 行还是 1M。可扩展性非常重要，如果从一开始就正确实施，将来肯定可以避免许多麻烦。

哦对，请不要忘记还有索引。
